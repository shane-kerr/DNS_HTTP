<?xml version="1.0"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced.
     An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC1035 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1035.xml">
<!ENTITY RFC5246 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC5625 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5625.xml">
<!ENTITY RFC7230 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml">
<!ENTITY RFC7231 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7231.xml">
<!ENTITY I-D.bortzmeyer-dns-json SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.draft-bortzmeyer-dns-json-01.xml">
<!ENTITY I-D.mohan-dns-query-xml SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.draft-mohan-dns-query-xml-00.xml">
<!ENTITY I-D.ietf-dnsop-5966bis SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-dnsop-5966bis-04.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<?rfc tocappendix="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="3"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<?rfc comments="no" ?>
<?rfc inline="yes" ?>
<rfc category="exp" docName="draft-song-dns-wireformat-http-00" ipr="trust200902">

  <front>

    <title>DNS wire-format over HTTP(S)</title>

    <author fullname="Linjian Song" initials="L." surname="Song">
      <organization>Beijing Internet Institute</organization>
      <address>
        <postal>
          <street>2508 Room, 25th Floor, Tower A, Time Fortune</street>
          <city>Beijing</city>
          <region></region>
          <code>100028</code>
          <country>P. R. China</country>
        </postal>
        <email>songlinjian@gmail.com</email>
        <uri>http://www.biigroup.com/</uri>
      </address>
    </author>


    <author fullname="Shane Kerr" initials="S." surname="Kerr">
      <organization>Beijing Internet Institute</organization>
      <address>
        <postal>
          <street>2/F, Building 5, No.58 Jinghai Road, BDA</street>
          <city>Beijing</city>
          <code>100176</code>
          <country>CN</country>
        </postal>
        <email>shane@biigroup.cn</email>
        <uri>http://www.biigroup.com/</uri>
      </address>
    </author>

    <author fullname="Runxia Wan" initials="R." surname="Wan">
      <organization>Beijing Internet Institute</organization>
      <address>
        <postal>
          <street>2508 Room, 25th Floor, Tower A, Time Fortune</street>
          <city>Beijing</city>
          <region></region>
          <code>100028</code>
          <country>P. R. China</country>
        </postal>
        <email>rxwan@biigroup.cn</email>
        <uri>http://www.biigroup.com/</uri>
      </address>
    </author>
    <date/>


    <!-- Meta-data Declarations -->

    <area>Internet Area</area>
    <workgroup>Internet Engineering Task Force</workgroup>

    <!-- <keyword>dns</keyword> -->

    <abstract>
      <t>
      In order to bypass DNS misbehavior on the path by the middle box, 
      this memo introduces a way to tunnel the DNS data on wire inside HTTP(s). 
      </t>

    </abstract>

  </front>

  <middle>

    <section title="Introduction">
    
    <t><xref target="RFC1035">RFC 1035</xref> specifies the wire format for DNS massage
      (both Header and RRs). And it also specifies DNS transport on UDP and TCP 
      on port 53, as we all used today. However, there are more flexible ways 
      proposed to access DNS database in different data format or alternative 
      DNS transport which is summarized in [draft-shane-review-DNS-over-http]. </t>

    <t>One of alternative way of DNS in this memo is to transport DNS binary data inside HTTP(s) 
      to fulfill the goal of enhancing availability of DNS service. The DNS traffic 
      is simply disguised into Web traffic using port 80/443 over HTTP. It can bypass
      stupid middle box like firewall, proxy or traffic sharping devices on path 
      which may jeopardize normal DNS traffic by misbehavior<xref target="RFC5625"/>
      <xref target="DOTSE"/><xref target="SAC035"/>.
    </t>

    <t>The great advantage to this approach is that HTTP usually makes it through 
      even the worst coffee shop or hotel room firewalls, since commerce may be 
      at stake. It also benefits from HTTP's support by default for persistent TCP 
      connection for all request [section 6.3 in RFC 7230]. Note that <xref target="I-D.ietf-dnsop-5966bis">5966bis</xref> tries to specify the persistent feature for 
      DNS on TCP/53. But the current DNS system is not ready for that. Lastly, 
      HTTPS will work, giving privacy.
    </t>

      <t>Unlike the REST DNS API using JSON <xref target="I-D.bortzmeyer-dns-json"/>
        and XML<xref target="I-D.mohan-dns-query-xml"/> encoding for DNS data, 
        wire-format data is wrapped with a HTTP header and transmitted on port 80 
        or 443. This protocol is not designed in favor of web developer or advance 
        usage in application development. It simply serves as a DNS VPN which dose not 
        require extra parsing for other format of DNS data.
       </t>

      <t>This memo is aim to introduce how the DNS binary over HTTP(s) concept works. 
        And hopefully implementation following this demo by different developers can 
        speak to each other.</t>

      <t>Note that this mechanism is designed for client sub-resolver to recursive server.
        DNS Zone transfer is no in the scope of this document.
      </t>

    </section>

    <section title="Methodology and Configuration">

      <t>As it is mentioned in introduction, the basic methodology is wrapping the DNS 
        wire-format data into HTTP(s) header and Transmitted on port 80 or 443. However, 
        there are two configuration scenarios for implementation.</t>

      <t>Scenario 1:</t>

      <t>DNS implementation handles DNS query and response via both UDP/TCP on port 53 
        and HTTP(s) on Port 80/443. That's means new function block is add to existing 
        DNS software as built-in API. It works as follows:</t>
      <t><list style="numbers">
        <t>The client creates a DNS query message.</t>
        <t>The client encapsulates the DNS message in a HTTP(S)
           message body and assigns parameters with the HTTP
           header.</t>
        <t>The client connects to the server and issues an HTTP(S)
           POST request method.</t>
        <t>The server decapsulates the HTTP package to DNS query, and
           resolves the DNS query.</t>
        <t>The server encapsulates the DNS response in HTTP(S) and
           sends it back via the HTTP(S) session.</t>
      </list>
      </t>
      <t>Scenario 2:</t>

      <t>In this scenario there is a DNS-HTTP proxy(client and server) sitting between 
        stub-resolver to recursive server. It works like a DNS VPN and transmit 
        Binary DNS massage over HTTP(s) between proxy client and server, as follows: </t>
      <t><list style="numbers">
        <t>The stub-resolver sends DNS query(over UDP or TCP) to proxy client</t>
        <t>The proxy client encapsulates the DNS message in a HTTP(S)
           message body and assigns parameters with the HTTP header.</t>
        <t>The proxy client connects to the proxy server and issues an HTTP(S)
           POST request method.</t>
        <t>The proxy server decapsulates the HTTP package to DNS query, and
           send it to real DNS server over UDP/TCP.</t>
        <t>The proxy server encapsulates the DNS response in HTTP(S) and
           sends it back via the HTTP(S) session.</t>
        <t>The proxy client decapsulates the DNS massage from HTTP(s) response 
          and sends it back to the stub-resolver via previous DNS session(over UDP or TCP)</t>
      </list>
       </t>

      <t>Not that the proxy client can be implemented listening to loop-back address 
        in the same host with stub-resolver. The proxy server can be implemented 
        with cache server as well. There is a trick integrating web server like nginx 
        and approach into proxy server </t>

    </section>

    <section title="DNS-over-HTTP Mssage Format">

      <t>In HTTP 1.1 specification section 3 in <xref target="RFC7230">RFC 7230</xref>, 
      a HTTP massage consists of three parts: start-line, header fields and message body 
      with an empty line between header fields and message body. The DNS over HTTP massage 
      also contains these parts.</t>

     <section title="Start-line"> 

      <t>By definition in HTTP start-line is either a request-line (for requests) or a 
        status-line (for responses). Request-line consists of request method, request-target 
        and HTTP-version with a CRLF in the end. </t>

      <t>For DNS query over HTTP, the request is always POST [section 4.3.3 in 
        <xref target="RFC7230">RFC 7230</xref>]. Note if a Get is sent to the server, it 
        optionally returns a human-readable page showing its web server environment.</t>

      <t>Usually the target URI is provides explicitly by the DNS services provider.
        Derived from the target URI, the request-target in request-line identifies the target
        resource upon which to apply the request. In the case of DNS query over HTTP, one 
        approach is to always use a fixed string for request-target by default, like "/dns-over-http". It works given there is no other resource share the same request-target name 
        which may introduce conflict and failure. Another approach is to allowed the server to defined URI which contains the specific request-target, like we use "/proxy_dns" for 
        Proxy implementation.</t>

      <t>The HTTP-version is always "HTTP/1.1". So the request-line is :</t>

      <t>POST /dns-over-http HTTP/1.1</t>

      <t>Regard to status-line, it returns status-code [Section 6 of 
        <xref target="RFC7231">RFC 7231</xref>] which only 
      reflects status of HTTP connection. If the request has succeeded, the status-line is:</t>

      <t>HTTP/1.1 200 OK</t>

      <t>Davey: Do we need to explore more in the status-code part for exception and failure case?</t>

      </section>

      <section title="Header Fields">

      <t>By definition header fields are key:value pairs that can be used to communicate 
        data about the message, its payload, the target resource, or the connection (i.e., 
        control data). Considering the proxy configuration in scenario 2, there is a new 
        heard filed: </t>

        <t>Proxy-DNS-Transport: xyz</t>

        <t>where xyz is either UDP or TCP, which is the client's indication of how it 
          received the underlying DNS query, and which the server will use when sending 
          the query to the far-end DNS server. This means if a stub DNS client asks for 
          TCP, then that's what the far-end DNS server will see, and likewise for UDP. 
          This header field is used for both request and response, for all DNS over HTTP 
          massage.
        </t>

        <t>Davey: I encounter a question here. Dose this memo just document the way of 
          proxy-dns or a general protocol for DNS Binary over HTTP(s). If we target the 
          general protocol format the proxy-dns is just one implementation case. And the 
          Proxy-DNS-Transport header field is optional.</t>

        <t>Davey: Do we need to document other header fields and controls? or simple 
          say use the default configuration? what's default? </t>

       </section>


      <section title="Message Body">

      <t>As it is mentioned, the message body is DNS wire-format data. The DNS query and 
        response are sent as raw binary via HTTP lib interface, such as the "libcurl" library 
        on the client side and the "libfcgi" library on the server side.</t>

      <t>It is worth mentioning that DNS messages sent over TCP connections is prefixed with 
        a two-byte length field which gives the message length[section 4.2.2 in <xref target="RFC1035">RFC 1035</xref>], 
        excluding the two-byte length field. This length field allows the low-level processing 
        to assemble a complete message before beginning to parse it. In the context of HTTP, 
        there is content-length header filed [section 3.3.2 in <xref target="RFC7230">RFC 7230</xref>]in which the field-value 
        is the same with two bytes length field in DNS over TCP. </t>

      <t>In normal configuration in figure 1, Both client/Server should assign value of DNS 
        message length to HTTP content-length field. In proxy configuration, if Proxy-DNS-Transport 
        is TCP, the proxy must aware the two-byte length field in DNS massage over TCP before 
        it handle HTTP request and response.</t>

      </section> 
      </section>

  <section title="Considerations on DNS over HTTPs">


      <t>As specified in  <xref target="RFC5246">RFC 5246</xref>, both the DNS
      server and client can be authenticated or not authenticated. The
      DNS service providers can decide authenticated pattern on both
      server and client sides based on their own requirement for security 
      and privacy. It is recommend that both client and server are not 
      require authentication for open resolver. </t>
    
    </section>


    <section title="IANA considerations">
    	<t>Registration for a new header field : Proxy-DNS-Transport</t>
    
    </section>
  
  </middle>

  <back>

    <references title="References">
      &RFC1035;&RFC5246;&RFC5625;&RFC7230;&RFC7231;
      &I-D.ietf-dnsop-5966bis;
      &I-D.bortzmeyer-dns-json;&I-D.mohan-dns-query-xml;

     
     <reference anchor="DOTSE" target="http://www.iis.se/docs/Routertester_en.pdf">
	        <front>
	                <title>DNSSEC Tests of Consumer Broadband Routers</title>
			<author fullname="Ahlund"></author>
			<author fullname="Wallstrom" ></author>
			<date year="2008" month="February" />            
	       	</front>
	   </reference>

		   <reference anchor="SAC035">
            <front>
                <title>DNSSEC Impact on Broadband Routers and Firewalls </title>
                <author>
                    <organization>ICANN Security and Stability Advisory Committee</organization>
                </author>
                <date year="2008" />
            </front>
     </reference>
     </references>

  </back>
</rfc>

