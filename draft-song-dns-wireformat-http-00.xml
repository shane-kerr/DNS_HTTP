<?xml version="1.0"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced.
     An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC1035 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1035.xml">
<!ENTITY RFC5246 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC5625 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5625.xml">
<!ENTITY RFC7230 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml">
<!ENTITY RFC7231 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7231.xml">
<!ENTITY RFC7540 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7540.xml">
<!ENTITY I-D.bortzmeyer-dns-json SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.draft-bortzmeyer-dns-json-01.xml">
<!ENTITY I-D.mohan-dns-query-xml SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.draft-mohan-dns-query-xml-00.xml">
<!ENTITY I-D.ietf-dnsop-5966bis SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-dnsop-5966bis-04.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<?rfc tocappendix="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="3"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<?rfc comments="no" ?>
<?rfc inline="yes" ?>
<rfc category="exp" docName="draft-song-dns-wireformat-http-00" ipr="trust200902">

  <front>

    <title>DNS wire-format over HTTP(S)</title>

    <author fullname="Linjian Song" initials="L." surname="Song">
      <organization>Beijing Internet Institute</organization>
      <address>
        <postal>
          <street>2508 Room, 25th Floor, Tower A, Time Fortune</street>
          <city>Beijing</city>
          <region></region>
          <code>100028</code>
          <country>P. R. China</country>
        </postal>
        <email>songlinjian@gmail.com</email>
        <uri>http://www.biigroup.com/</uri>
      </address>
    </author>


    <author fullname="Shane Kerr" initials="S." surname="Kerr">
      <organization>Beijing Internet Institute</organization>
      <address>
        <postal>
          <street>2/F, Building 5, No.58 Jinghai Road, BDA</street>
          <city>Beijing</city>
          <code>100176</code>
          <country>CN</country>
        </postal>
        <email>shane@biigroup.cn</email>
        <uri>http://www.biigroup.com/</uri>
      </address>
    </author>

    <author fullname="Runxia Wan" initials="R." surname="Wan">
      <organization>Beijing Internet Institute</organization>
      <address>
        <postal>
          <street>2508 Room, 25th Floor, Tower A, Time Fortune</street>
          <city>Beijing</city>
          <region></region>
          <code>100028</code>
          <country>P. R. China</country>
        </postal>
        <email>rxwan@biigroup.cn</email>
        <uri>http://www.biigroup.com/</uri>
      </address>
    </author>
    <date/>


    <!-- Meta-data Declarations -->

    <area>Internet Area</area>
    <workgroup>Internet Engineering Task Force</workgroup>

    <!-- <keyword>dns</keyword> -->

    <abstract>
      <t>
      This memo introduces a way to tunnel DNS data over HTTP. This
      may be useful in any situation where DNS is not working
      properly, such as when there is middlebox misbehavior.
      </t>

    </abstract>

  </front>

  <middle>

    <section title="Introduction">
    
    <t><xref target="RFC1035">RFC 1035</xref> specifies the wire
      format for DNS messages.  It also specifies DNS transport on UDP
      and TCP on port 53, which is still used today. However, there
      are other ways to access DNS database, for example in a
      different data format or via alternative DNS transport. These
      approaches are summarized in
      [draft-shane-review-DNS-over-http].</t>

    <t>One of alternative way of DNS described in that document is to
      transport DNS binary data inside HTTP, with the goal of
      improving DNS service availability. The DNS traffic is simply
      sent as web traffic using port 80/443 over HTTP. It can bypass
      badly behaving middle boxes like firewalls, proxyiesor traffic
      shaping devices on path which might interfere with normal DNS
      traffic <xref target="RFC5625"/> <xref target="DOTSE"/> <xref
      target="SAC035"/>.
    </t>

    <t>This approach has the advantage that HTTP usually makes it through 
      even the worst coffee shop or hotel room firewalls, as Internet
      users expect web browsing to always work. It also benefits from
      HTTP's support for persistent TCP connections (see section 6.3
      in <xref target="RFC7230"/>). Note that <xref
      target="I-D.ietf-dnsop-5966bis">5966bis</xref> specifies the
      persistent feature for DNS on TCP port 53, but current DNS
      software does not genreally support this mode of operation.
      Finally, HTTPS provides data integrity and privacy.
    </t>

    <t>Unlike a REST DNS API using JSON <xref target="I-D.bortzmeyer-dns-json"/>
        or XML <xref target="I-D.mohan-dns-query-xml"/> encoding for
        DNS data, in this approach wire-format data is wrapped with a
        HTTP header and transmitted on port 80 or 443. This protocol
        is not designed with web developers or advanced usage in
        application development in mind. It simply serves as a sort of
        DNS VPN, and does not introduce another format of DNS data.
       </t>

      <t>This memo aims to describe how the DNS binary over HTTP
        concept works. Hopefully implementations by different
        developers following this memo can speak with each other.
      </t>

      <t>This mechanism is designed for client stub resolver to
        recursive server. DNS zone transfer, DNS updates, and anything
        other than simple DNS queries are out-of-scope for this
        document.
      </t>

    </section>

    <section title="Methodology and Configuration">

      <t>As mentioned in introduction, the basic methodology is
        wrapping the DNS wire-format data into an HTTP header and
        transmitting on port 80 or 443. However, there are two
        different scenarios for implementation.</t>

      <t>Scenario 1:</t>

      <t>The DNS server implementation handles DNS queries and
        responses via both UDP and TCP on port 53, and HTTP on port 80
        or 443. It works as follows:</t>
      <t><list style="numbers">
        <t>The client creates a DNS query message.</t>
        <t>The client encapsulates the DNS message in a HTTP
           message body and assigns parameters with the HTTP
           header.</t>
        <t>The client connects to the server and issues an HTTP
           POST request method. This may re-use an existing HTTP
           connection.</t>
        <t>The server decapsulates the HTTP packet to get the DNS
           query, and resolves the DNS query.</t>
        <t>The server encapsulates the DNS response in HTTP and
           sends it back via the HTTP session.</t>
      </list>
      </t>
      <t>Scenario 2:</t>

      <t>In this scenario there is a DNS-HTTP proxy sitting between
        stub-resolver and the recursive server. The stub uses a client
        proxy and the recursive server uses a server proxy. This works
        like a DNS VPN and transmits wire-format DNS messages over
        HTTP between the proxy client and a server, as follows:</t>
      <t><list style="numbers">
        <t>The stub-resolver sends a DNS query (over UDP or TCP) to
           the proxy client.</t>
        <t>The proxy client encapsulates the DNS message in an HTTP
           message body and assigns parameters with the HTTP header.</t>
        <t>The proxy client connects to the proxy server and issues an
           HTTP POST request method. This may re-use an existing HTTP
           connection.</t>
        <t>The proxy server decapsulates the HTTP packet to get the
           DNS query, and sends it to a real DNS server over UDP/TCP.</t>
        <t>The proxy server encapsulates the DNS response in HTTP and
           sends it back via the HTTP session.</t>
        <t>The proxy client decapsulates the DNS message from the HTTP
          response and sends it back to the stub-resolver via previous
          DNS session (either UDP or TCP).</t>
      </list>
       </t>

      <t>Note that the proxy client can be implemented listening to a
        loop-back address in the same host with stub-resolver. The
        proxy server can be implemented as a caching server as well.
        It is also possible to use the proxy server as a regular web
        server at the same time that is is acting as a proxy
        server.</t>

    </section>

    <section title="DNS-over-HTTP Message Format">

      <t>
      Although this document is simply proposes that HTTP be used for DNS massage exchange, 
      it is informative to explore the context with HTTP-specific semantics, such as HTTP 
      request method, specific request-target, HTTP-version and HTTP header field, which 
      have impact on interoperability as well as performance. 
      </t>

      <t>In HTTP 1.1 specification section 3 in <xref target="RFC7230">RFC 7230</xref>, 
      an HTTP message consists of three parts: start-line, header
      fields, and message body with an empty line between header
      fields and message body. The DNS over HTTP message also contains
      these parts.</t>

     <section title="Start-line"> 

      <t>By definition the HTTP start-line is either a request-line (for requests) or a 
        status-line (for responses). A request-line consists of the request
        method, request-target, and HTTP-version with a CRLF in the end.</t>

      <t>For a DNS query over HTTP, the request is always POST [section 4.3.3 in 
        <xref target="RFC7230">RFC 7230</xref>]. Note if a GET is sent to the server, it 
        optionally returns a human-readable page showing its web server environment.</t>

      <t>Usually the target URI is provides explicitly by the DNS services provider.
        Derived from the target URI, the request-target in request-line identifies the target
        resource upon which to apply the request. In the case of DNS query over HTTP, one 
        approach is to always use a fixed string for request-target by
        default, like "/dns-over-http". It works if there is no
        other resource sharing the same request-target name, otherwise
        there may be a conflict. Another approach is to allow the
        server to use a defined URI which contains the specific
        request-target. Note in the BII proxy implementation, we use
        "/proxy_dns" for this purpose.</t>

      <t>
        DNS transaction over HTTP has no specific requirement for transport protocol, 
        developer can use any version of HTTP to accomplish the transaction. But developer 
        should be aware that HTTP/1.x <xref target="RFC7230">RFC 7230</xref>and HTTP/2 <xref target="RFC7540">RFC 7540</xref> do have difference in performance regarding 
        multiplexing. HTTP/2 is fully multiplexed, instead of ordered and blocking. Because 
        there is a general desire to achieve similar performance with DNS over UDP, the modern 
        HTTP/2 is preferred for DNS over HTTP implementation. Note that there should be no 
        problem for advanced HTTP protocol in the future deployed for DNS over HTTP.
      </t>

      <t>For example, given HTTP-version is "HTTP/1.1". So the request-line is :</t>

      <t>POST /dns-over-http HTTP/1.1</t>

      <t>The status-line returns the status-code [Section 6 of 
        <xref target="RFC7231">RFC 7231</xref>], which only 
      reflects status of HTTP connection. If the request has succeeded, the status-line is:</t>

      <t>HTTP/1.1 200 OK</t>

      <t>If the request fails, the proxy server will supply an
         appropriate error code, typically 4xx (client error) if the
         client has provided a query that the server cannot understand
         for some reasons, or 5xx (server error) if some server-side
         problem prevented a query from succeeding.</t>

      </section>

      <section title="Header Fields">

      <t>By definition header fields are key:value pairs that can be used to communicate 
        data about the message, its payload, the target resource, or
        the connection (for example control data). Considering the
        proxy configuration in scenario 2, we use a new header field: </t>

        <t>Proxy-DNS-Transport: xyz</t>

        <t>Where xyz is either UDP or TCP, which is the client's indication of how it 
          received the underlying DNS query, and which the server will use when sending 
          the query to the far-end DNS server. This means if a stub DNS client asks for 
          TCP, then that's what the far-end DNS server will see, and likewise for UDP. 
          This header field is used for both request and response, for all DNS over HTTP 
          message.
        </t>

       </section>


      <section title="Message Body">

      <t>As mentioned, the message body is DNS wire-format data.</t>

      <t>It is worth mentioning that DNS messages sent over TCP connections is prefixed with 
        a two-byte length field which gives the message length[section 4.2.2 in <xref target="RFC1035">RFC 1035</xref>], 
        excluding the two-byte length field. This length field allows the low-level processing 
        to assemble a complete message before beginning to parse it. In the context of HTTP, 
        there is content-length header filed [section 3.3.2 in <xref target="RFC7230">RFC 7230</xref>]in which the field-value 
        is the same with two bytes length field in DNS over TCP. </t>

      <t>In normal configuration, both client and server should assign
        a value for the DNS message length to HTTP content-length
        field. In proxy configuration, if Proxy-DNS-Transport 
        is TCP, the proxy must aware the two-byte length field in DNS
        message over TCP before it handle HTTP request and
        response.</t>

      </section> 
      </section>

  <section title="Considerations on DNS over HTTPS">

      <t>HTTPS is recommended for communication. It provides privacy
      and integrity for HTTP sessions.</t>

      <t>As specified in  <xref target="RFC5246">RFC 5246</xref>, both the DNS
      server and client can be authenticated or not authenticated. The
      DNS service providers can decide authenticated pattern on both
      server and client sides based on their own requirement for security 
      and privacy. For an open resolver, clients do not require
      authentication. </t>
    
    </section>


    <section title="IANA considerations">
    	<t>Registration for a new HTTP header field: Proxy-DNS-Transport</t>
    
    </section>
  
  </middle>

  <back>

    <references title="References">
      &RFC1035; &RFC5246; &RFC5625; &RFC7230; &RFC7231;&RFC7540;
      &I-D.ietf-dnsop-5966bis;
      &I-D.bortzmeyer-dns-json;&I-D.mohan-dns-query-xml;

     
     <reference anchor="DOTSE" target="http://www.iis.se/docs/Routertester_en.pdf">
	        <front>
	                <title>DNSSEC Tests of Consumer Broadband Routers</title>
			<author fullname="Ahlund"></author>
			<author fullname="Wallstrom" ></author>
			<date year="2008" month="February" />            
	       	</front>
	   </reference>

		   <reference anchor="SAC035">
            <front>
                <title>DNSSEC Impact on Broadband Routers and Firewalls </title>
                <author>
                    <organization>ICANN Security and Stability Advisory Committee</organization>
                </author>
                <date year="2008" />
            </front>
     </reference>
     </references>

  </back>
</rfc>

